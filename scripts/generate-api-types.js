import fs from 'fs';
import path from 'path';
import openapiTS, { astToString } from 'openapi-typescript';
import { bootstrapEnv, getLogger } from '@zeffuro/fakegaming-common';
const log = getLogger({ name: 'gen:api-types' });
const { __dirname: ROOT } = bootstrapEnv(import.meta.url);
async function main() {
    const openApiPath = path.resolve(ROOT, '../packages/api/openapi.json');
    const outDir = path.resolve(ROOT, '../packages/common/types');
    const outFile = path.join(outDir, 'api.d.ts');
    const outAliases = path.join(outDir, 'apiResponses.d.ts');
    if (!fs.existsSync(openApiPath)) {
        throw new Error(`[generate-api-types] Missing OpenAPI file at ${openApiPath}. Build API first.`);
    }
    const openApiText = fs.readFileSync(openApiPath, 'utf8');
    const schema = JSON.parse(openApiText);
    // Generate types from OpenAPI
    const nodes = await openapiTS(schema);
    const dts = astToString(nodes);
    fs.mkdirSync(outDir, { recursive: true });
    fs.writeFileSync(outFile, dts);
    log.info({ outFile }, 'Wrote OpenAPI types');
    // Generate alias d.ts (types-only) similar to dashboard/generateApiAliases.ts
    const aliasLines = [
        `import type { paths } from "@zeffuro/fakegaming-common/api-types";`,
        '',
        '// ----- Autogenerated endpoint type aliases (types-only) -----',
        '',
    ];
    const pathsObj = (schema.paths ?? {});
    for (const [route, verbs] of Object.entries(pathsObj)) {
        const verbMap = (verbs ?? {});
        for (const [method, details] of Object.entries(verbMap)) {
            const d = (details ?? {});
            if (d && typeof d === 'object' && 'responses' in d) {
                const responses = d.responses;
                for (const [status, resp] of Object.entries(responses ?? {})) {
                    const content = resp?.content?.['application/json'];
                    if (content) {
                        aliasLines.push(`/**`, ` * Response for [${method.toUpperCase()} ${route} ${status}]`, ` *`, ` * @see paths["${route}"]["${method}"]["responses"]["${status}"]["content"]["application/json"]`, ` */`);
                        const aliasName = route
                            .replace(/[\\/{}]/g, '_')
                            .replace(/_{2,}/g, '_')
                            .replace(/^_+|_+$/g, '')
                            .replace(/[^A-Za-z0-9_]/g, '') + `_${method}_Response${status}`;
                        aliasLines.push(`export type ${aliasName} = paths["${route}"]["${method}"]["responses"]["${status}"]["content"]["application/json"];`, '');
                    }
                }
            }
            const body = d?.requestBody?.content?.['application/json'];
            if (body) {
                aliasLines.push(`/**`, ` * Request body for [${method.toUpperCase()} ${route}]`, ` *`, ` * @see paths["${route}"]["${method}"]["requestBody"]["content"]["application/json"]`, ` */`);
                const aliasName = route
                    .replace(/[\\/{}]/g, '_')
                    .replace(/_{2,}/g, '_')
                    .replace(/^_+|_+$/g, '')
                    .replace(/[^A-Za-z0-9_]/g, '') + `_${method}_Request`;
                aliasLines.push(`export type ${aliasName} = paths["${route}"]["${method}"]["requestBody"]["content"]["application/json"];`, '');
            }
        }
    }
    fs.writeFileSync(outAliases, aliasLines.join('\n'));
    log.info({ outAliases }, 'Wrote OpenAPI alias types');
}
main().catch((err) => {
    console.error(err);
    process.exit(1);
});
