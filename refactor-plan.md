# FakeGaming Bot Architecture Refactor Plan (2025-10-08)

This document summarizes findings and recommendations generated by GPT-5.
It is intended to guide architectural and testing refactors across API, Bot, and Common packages.

## Context Summary

I’m going to review the current layering and tests based on your repo, then propose a concrete, safer layout and targeted refactors you can apply.
Checklist:
Map current structure and boundaries (routes/services/managers/models) and dependency flow.
Evaluate API design and test patterns; identify friction points and flakiness drivers.
Propose an improved architecture layout and interaction patterns (DI/Repository/Factory).
Provide concrete, file-specific refactors for the files reviewed.
Summarize with a diagram and a prioritized rollout plan.
What I examined (key files and findings):
Managers and models:
packages/common/src/managers/baseManager.ts
packages/common/src/managers/patchNotesManager.ts
packages/common/src/managers/quoteManager.ts
packages/common/src/managers/configManager.ts and managers/index.ts
packages/common/src/models/patch-note-config.ts and models/patch-subscription-config.ts
API routes:
packages/api/src/routes/patchNotes.ts
packages/api/src/routes/patchSubscriptions.ts
packages/api/src/routes/quotes.ts
packages/api/src/utils/createBaseRouter.ts and middleware/auth.ts
Bot service and embed:
packages/bot/src/services/patchNotesService.ts
packages/bot/src/modules/patchnotes/shared/patchNoteEmbed.ts and tests
Testing helpers:
packages/common/src/testing/index.ts
packages/common/src/testing/utils/testUtils.ts
packages/common/src/testing/mocks/managerMock.ts and modelMock.ts
vitest.setup.ts in common/bot/api
Architecture structure and boundaries review
Positives
Clear layering:
Models (Sequelize) in packages/common/src/models.
Data-access managers in packages/common/src/managers extend BaseManager<t>.</t>
API routes (controllers) in packages/api/src/routes use getConfigManager().<manager>.</manager>
Bot service code encapsulates domain workflows (e.g., patchNotesService.ts).
Consistent ESM usage with .js extensions.
Router factory wraps handlers to propagate errors cleanly (createBaseRouter).
Findings and structural issues
Inconsistent manager APIs used by routes:
In routes (quotes.ts, patchNotes.ts, patchSubscriptions.ts) you call getAllPlain(), findByPkPlain(), addPlain(), but these helpers are not uniformly defined. BaseManager exposes getAll({ raw: true }) et al, but not “Plain” helpers; some managers (ReminderManager, BirthdayManager) add “getAllPlain”, but PatchNotesManager doesn’t. Result: routes compile/runtime inconsistencies and increased cognitive overhead.
QuoteManager method signatures vs routes:
QuoteManager defines getQuotesByGuild(guildId), getQuotesByAuthor(guildId, authorId), searchQuotes(guildId, text).
API routes call them with parameter objects: getQuotesByGuild({ guildId }) and searchQuotes({ guildId, text }). That’s a mismatch that will break or force any-casting.
Model instance vs plain object confusion in services:
packages/bot/src/services/patchNotesService.ts calls buildPatchNoteEmbed(note.get({ raw: true })) after retrieving notes with getAll({ raw: true }), which already returns plain objects. This will throw at runtime (note.get is not a function). Tests currently mask this by spying getAll to return objects that implement .get manually.
Type drift for publishedAt:
PatchNoteConfig model defines publishedAt as DataType.BIGINT (number), but tests and embed builder accept Date or number. Comparison logic in announceNewPatchNotes compares note.publishedAt (possibly number/date) to sub.lastAnnouncedAt (possibly number/date). This will work loosely but is brittle and relies on implicit coercion; it also opens the door to regression when switching storage or mocks.
Default exports in routes:
Some routes use export default router (patchNotes.ts, patchSubscriptions.ts); others export named exports. Your coding instructions say “Use named exports only”. This inconsistency increases friction when refactoring or doing tree-shaking and goes against your repo’s conventions.
Global singleton access in services:
announceNewPatchNotes uses getConfigManager() inside the function, while scanAndUpdatePatchNotes(patchNotesManager) accepts the manager as a parameter. Mixed patterns make testing and composition harder. Prefer dependency injection (DI) consistently.
BaseManager.upsert does a precompute of a where object for conflict keys but doesn’t use it in Sequelize.upsert. It’s benign but confusing and could be simplified or explained.
Dependency flow health
Common (models/managers) is depended on by bot and api. No circulars detected.
Tests mock @zeffuro/fakegaming-common/managers via doMock; good capability, but mocks currently hide the service bug noted above.
API and testing design evaluation
API design
Routes are thin and mostly delegate to managers—good. However, validation and input shape mapping is inconsistent:
quotes.ts builds objects and passes them into manager methods that expect positional args.
patchNotes.ts uses a “patchVersion || version” shim; consider normalizing DTOs in a service or a validator layer (zod/valibot/yup) before calling managers.
Error handling: You rely on async wrapper and status code handling. Consider a central error middleware mapping NotFoundError/ValidationError to proper status codes.
Testing design
Shared testing utilities are solid: setupServiceTest, manager mocks, model mocks, Discord mocks.
However:
The service test for patch notes constructs test data with a manual .get() to mask a real-world failure path. This indicates test fragility; tests should assert against real manager outputs. Prefer using the model mocks provided via setupModelMocks or return plain data if the code under test expects plain.
There’s no canonical “getAllPlain” in BaseManager, so tests and routes diverge.
Integration tests for API routes would be simpler if you had a createApp factory that accepted a ConfigManager (or a partial) so supertest-based integration tests can be run with in-memory SQLite or pure mocks.
How to simplify mocking / integration
Provide standardized Plain helpers in BaseManager (getAllPlain, getOnePlain, findByPkPlain, addPlain) so routes/tests don’t have to juggle raw flags and instance methods.
Normalize DTOs at the boundary:
Define domain DTOs for “plain objects” in common, e.g., type PatchNoteDTO = CreationAttributes<patchnoteconfig> & { id?: number }. Use these types across routes/services instead of Sequelize model instances.</patchnoteconfig>
Introduce AppContext/DI:
Have services accept their dependencies explicitly (e.g., announceNewPatchNotes({ client, patchNotesManager, patchSubscriptionManager })). This makes tests simpler—no reliance on hidden singletons.
Provide API app factory:
createApiApp(deps: { configManager: ConfigManager }) returning an Express app. Tests can supertest(app) with mocked managers, or compose an in-memory sqlite Sequelize instance.
Improved architecture layout
Recommended folder/file hierarchy (high-level)
packages/common
src/
models/
index.ts (barrel)
patch-note-config.ts
patch-subscription-config.ts
…
repositories/ or managers/
baseManager.ts
patchNotesManager.ts
quoteManager.ts
…
index.ts (barrel)
dto/
patchNotes.ts (PatchNoteDTO, PatchSubscriptionDTO…)
quotes.ts (QuoteDTO…)
services/ (optional domain services if needed across api/bot)
errors/
apiErrorHelpers.ts (NotFoundError, ValidationError…)
testing/
mocks/
utils/
index.ts
sequelize.ts and migrate.ts
packages/api
src/
app/
createApp.ts (pure factory taking dependencies; wires middlewares/routes)
routes/
quotes.router.ts (named export router)
patchNotes.router.ts
patchSubscriptions.router.ts
controllers/ (optional; move handler functions out of router files if they grow)
middleware/
utils/
tests/
integration/
app.test.ts
quotes.routes.test.ts
packages/bot
src/
services/
patchNotesService.ts (accept dependencies via params)
modules/
patchnotes/
shared/patchNoteEmbed.ts
quotes/
loaders/
utils/
Interaction patterns
Routes:
Only parse/validate input and call a service function or manager.
No data access directly if service logic exists; otherwise, routes can call managers through a use-case oriented service.
Services:
Accept explicit dependencies (managers/clients). No global getConfigManager() inside services.
Return DTOs (plain objects) to callers.
Managers:
Pure data access, no business logic.
Provide standardized “Plain” helpers to avoid accidental instance/object confusion.
Tests:
Unit tests mock managers/services via factories.
Integration tests use createApp and supertest; can run with in-memory sqlite or mocks.
Concrete refactor proposals for the files reviewed
A. BaseManager: add standardized “Plain” helpers
Why: unify route/tests usage and avoid raw flags repeated everywhere. Your routes already assume getAllPlain/findByPkPlain/addPlain exist.
Add these thin wrappers to baseManager.ts:
getAllPlain(): Promise<CreationAttributes<t>[]></t>
getManyPlain(where)
getOnePlain(where)
findByPkPlain(id)
addPlain(attributes)
updatePlain(attributes, where): returns [count, CreationAttributes<t>[]]</t>
Benefit: routes and tests become consistent; less casting; managerMock dynamically mocks BaseManager methods so tests won’t break—these new methods will be present on all mock managers automatically.
B. QuoteManager and quotes routes: fix signature mismatches
Option 1 (lighter): adjust API routes to call QuoteManager with positional args:
getQuotesByGuild(guildId)
getQuotesByAuthor(guildId, authorId)
searchQuotes(guildId, text)
Replace addPlain with addQuote or BaseManager.addPlain as desired.
Option 2 (if you prefer object params): change QuoteManager to accept parameter objects consistently:
getQuotesByGuild({ guildId })
getQuotesByAuthor({ guildId, authorId })
searchQuotes({ guildId, text })
I recommend Option 1 to minimize churn; the manager APIs are already written this way.
C. patchNotesService: fix instance/plain confusion and add robust date comparisons
Replace buildPatchNoteEmbed(note.get({ raw: true })) with buildPatchNoteEmbed(note) if note is already plain (as returned by getAll({ raw: true })).
Normalize time comparison:
Implement a tiny helper in the service: const toMillis = (v: number | Date | null | undefined) => (v instanceof Date ? v.getTime() : typeof v === 'number' ? v : 0);
Use it: if (!subTime || noteTime > subTime) { … }
Keep using upsert for subscriptions; or switch to a dedicated method (upsertSubscription) for clarity.
D. API routes for patchNotes/patchSubscriptions: unify “Plain” usage and export style
Use getAllPlain consistently once BaseManager exposes it.
Consider migrating export default router to named export: export { router }. This aligns with your “named exports only” rule. You’ll need to update the app wiring imports (createApp or wherever routes are attached).
E. DTOs and validation
Define DTOs for PatchNote and PatchSubscription in common/src/dto/patchNotes.ts, reflecting the “plain” structure used on the wire and by services.
Add a simple schema validator for request bodies (e.g., zod) in API route handlers to normalize fields (patchVersion vs version) and return typed DTOs. This removes the ad-hoc req.body.patchVersion || req.body.version logic from handlers.
F. Testing improvements
setupServiceTest is good. Add a parallel setupApiTest:
createApiApp({ configManager: createMockConfigManager(overrides) }); return { app, configManager }.
Run supertest(app) to test routes end-to-end with stable mocks.
Fix mocks to reflect real shapes:
Ensure model mocks produce plain objects where code expects plain; avoid requiring .get() unless the code truly consumes models.
For patch note tests, don’t stub .get() to mask the bug; let the service use the same shape as real manager returns.
G. Minor cleanups
Remove unused imports (e.g., NotFoundError in quotes.ts).
In BaseManager.upsert, either document why the where keys are checked or simplify if relying solely on sequelize upsert behavior. Optionally use conflictFields to validate presence only.
Suggested refactored diagram (layers and flow)
Bot: Discord Client -> Services (announceNewPatchNotes, scanAndUpdatePatchNotes) -> Managers (PatchNotesManager, PatchSubscriptionManager) -> Sequelize Models (PatchNoteConfig, PatchSubscriptionConfig)
API: Express Router -> Controller Handler (thin) -> Services (optional) -> Managers -> Models
Common: DTOs (plain shapes) <-> Managers (data access) <-> Models (Sequelize) Testing: Mocks (managers/models/discord/cache) + Utilities (setupServiceTest, setupApiTest)
Example improved layout (subset)
packages/common/src
models/
patch-note-config.ts
patch-subscription-config.ts
index.ts
managers/
baseManager.ts // adds getAllPlain, getOnePlain, …
patchNotesManager.ts
quoteManager.ts
index.ts
configManager.ts
configManagerSingleton.ts
dto/
patchNotes.ts // export type PatchNoteDTO, PatchSubscriptionDTO
quotes.ts // export type QuoteDTO
errors/
apiErrorHelpers.ts
testing/
mocks/
utils/
index.ts
sequelize.ts
migrate.ts
packages/api/src
app/
createApp.ts // accepts { configManager }; mounts routes; exported for tests
routes/
quotes.router.ts // export { router }; call manager methods with correct signatures
patchNotes.router.ts
patchSubscriptions.router.ts
middleware/
utils/
tests/integration/
quotes.routes.test.ts
patchNotes.routes.test.ts
packages/bot/src
services/
patchNotesService.ts // announceNewPatchNotes({ client, patchNotesManager, patchSubscriptionManager })
modules/patchnotes/shared/patchNoteEmbed.ts
Prioritized rollout plan
Fix correctness issues:
In patchNotesService.ts, remove .get() when passing note to buildPatchNoteEmbed; normalize timestamp comparisons to milliseconds.
In quotes.ts route, adjust calls to QuoteManager signatures (positional args), remove unused NotFoundError import.
Add BaseManager “Plain” helpers:
Implement getAllPlain, getOnePlain, findByPkPlain, addPlain, getManyPlain, updatePlain. Switch routes to these helpers gradually (patchNotes.ts already expecting getAllPlain).
Introduce a createApiApp factory:
Move app wiring to a function that accepts dependencies. This simplifies integration tests and future DI.
Normalize DTOs and validation:
Add DTO types to common, use them in routes/services. Add zod validation in routes to produce DTOs before using managers.
Standardize exports:
Switch routes to named exports and update imports.
Testing improvements:
Add setupApiTest using supertest; ensure mocks return plain objects where expected. Remove masking of instance/plain mismatches in tests.
Requirements coverage
Architecture boundaries: Issues found and fixes proposed (clear separation, DI, standard helpers).
API/testing design: Simplifications (BaseManager Plain helpers, DTOs, createApiApp, robust mocks).
Improved layout: Provided hierarchy and interaction patterns.
Concrete refactors: Specific file-level guidance for baseManager, quotes.ts, patchNotesService.ts, patchNotes.ts.
Optional next steps if you want me to apply changes
I can:
Add BaseManager Plain helpers.
Fix patchNotesService embed call and timestamp compare.
Update quotes.ts to match QuoteManager signatures and remove unused imports.
Update patchNotes.ts to use getAllPlain if not already present.
Add a minimal createApiApp and one integration test as a pattern.
Quick notes on impacts
Adding Plain helpers to BaseManager is backward-compatible; your manager mocks dynamically include BaseManager methods, so tests won’t break and can start using these helpers.
Fixing patchNotesService removes a real runtime bug currently hidden by tests.
Adjusting quotes.ts avoids implicit any and signature mismatch issues.
If you want, I can implement the minimal safe refactors (A, C, and B Option 1), then run tests to ensure everything is green.